# postgresql全文搜索

> gaomingjie
>
> Email: jackgo73@outlook.com
>
> Date:  20180611

## 背景

根据手册内容总结实践full text search。文档总结笔记在每一节的**“我来理解一下”**。

## 介绍

- 全文搜索提供了确定满足一个查询的自然语言文档的能力，并可以选择将它们按照与查询的相关度排序。
- PostgreSQL对 文 本 数 据 类 型 提 供了~、~*、LIKE和ILIKE操作符吗，缺点：
  - 缺乏语言的支持。正则表达式是不够的，因为它们不能很容易地处理派生词，例如satisfies和satisfy。你可能会错过包含satisfies的文档，尽管你可能想要在对于satisfy的搜索中找到它们。可以使用OR来搜索多个派生形式，但是这样做太罗嗦也容易出错（有些词可能有数千种派生）。 
- 不能提供对搜索结果的排序（排名），这使它们面对数以千计被找到的文档时变得无效。 
- 它们很慢因为没有索引支持，因此它们必须为每次搜索处理所有的文档。 



全文检索上场：

- 全文索引允许文档被预处理并且保存一个索引用于以后快速的搜索。预处理包括： 
  - 将文档解析成记号。标识出多种类型的记号是有所帮助的，例如数字、词、复杂的词、电子邮件地址，这样它们可以被以不同的方式处理。原则上记号分类取决于相关的应用，但是对于大部分目的都可以使用一套预定义的分类。PostgreSQL使用一个解析器来执行这个步骤。其中提供了一个标准的解析器，并且为特定的需要也可以创建定制的解析器。 
  - 将记号转换成词位。和一个记号一样，一个词位是一个字符串，但是它已经被正规化，这样同一个词的不同形式被变成一样。例如，正规化几乎总是包括将大写字母转换成小写形式，并且经常涉及移除后缀（例如英语中的s或es）。这允许搜索找到同一个词的变体形式，而不需要冗长地输入所有可能的变体。此外，这个步骤通常会消除停用词，它们是那些太普通的词，它们对于搜索是无用的（简而言之，记号是文档文本的原始片段，而词位是那些被认为对索引和搜索有用的词）。PostgreSQL使用词典来执行这个步骤。已经提供了多种标准词典，并且为特定的需要也可以创建定制的词典。 
  - 为搜索优化存储预处理好的文档。例如，每一个文档可以被表示为正规化的词位的一个有序数组。与词位一起，通常还想要存储用于近似排名的位置信息，这样一个包含查询词更“密集”区域的文档要比那些包含分散的查询词的文档有更高的排名。
- 词典允许对记号如何被正规化进行细粒度的控制。使用合适的词典，你可以： 
  - 定义不应该被索引的停用词。
  - 使用Ispell把同义词映射到一个单一词。
  - 使用一个分类词典把短语映射到一个单一词。
  - 使用一个Ispell词典把一个词的不同变体映射到一种规范的形式。
  - 使用Snowball词干分析器规则将一个词的不同变体映射到一种规范的形式。 
- 提供了一种数据类型tsvector来存储预处理后的文档，还提供了一种类型tsquery来表示处理过的查询（Section 8.11）。有很多函数和操作符可以用于这些数据类型（Section 9.13），其中最重要的是匹配操作符@@，它在Section 12.1.2中介绍。全文搜索可以使用索引来加速（Section 12.9）。 

---

**我来理解一下**

- 全文搜索是预处理了一下之后产生了一个索引
- 预处理先把文档做分词，然后给每个词都做记号，然后把记号转成词位，词位是标准化的记号。（例如同一个词的不同形式的记号相同）pg有词典来做这个事情。
- tsvector来存储预处理后的文档 
- tsquery来表示处理过的查询 

---

### 什么是一个文档？ 

- 一个document是在一个全文搜索系统中进行搜索的单元，例如，一篇杂志文章或电子邮件消息。文本搜索引擎必须能够解析文档并存储词位（关键词）与它们的父文档之间的关联。随后，这些关联会被用来搜索包含查询词的文档。

- 对于PostgreSQL中的搜索，一个文档通常是一个数据库表中一行内的一个文本形式的域，或者可能是这类域的一个组合（连接），这些域可能存储在多个表或者是动态获取。换句话说，一个文档可能从用于索引的不同部分构建，并且它可能被作为一个整体存储在某个地方。例如：

   ```sql
   SELECT title || ’ ’ || author || ’ ’ || abstract || ’ ’ || body AS document
   FROM messages
   WHERE mid = 12;
   ```
   ```sql
   SELECT m.title || ’ ’ || m.author || ’ ’ || m.abstract || ’ ’ || d.body AS document
   FROM messages m, docs d
   WHERE mid = did AND mid = 12;
   ```

- 另一种存储文档的可能性是作为文件系统中的简单文本文件。在这种情况下，数据库可以被用来存储全文索引并执行搜索，并且某些唯一标识符可以被用来从文件系统检索文档。但是，从数据库的外面检索文件要求超级用户权限或者特殊函数支持，因此这种方法通常不如把所有数据放在PostgreSQL内部方便。另外，把所有东西放在数据库内部允许方便地访问文档元数据来协助索引和现实。

- 对于文本搜索目的，每一个文档必须被缩减成预处理后的tsvector格式。搜索和排名被整个在一个文档的tsvector表示上执行 — 只有当文档被选择来显示给用户时才需要检索原始文本。我们因此经常把tsvector说成是文档，但是当然它只是完整文档的一种紧凑表示。****

---

**我来理解一下**

- 全文搜索的原始文本最好存在数据库里面
- 文档都会被预处理成tsvector的格式，内部处理都是用的这个数据结构，之后最终显示的时候再检索原始文本。

---

### 基本文本匹配 

PostgreSQL中 的 全 文 搜 索 基 于 匹 配 操 作 符@@， 它 在 一 个tsvector（ 文 档 ） 匹 配 一个tsquery（查询）时返回true。哪种数据类型写在前面没有影响：

```sql
SELECT 'a fat cat sat on a mat and ate a fat rat'::tsvector @@ 'cat & rat'::tsquery;
?column?
----------
t
SELECT 'fat & cow'::tsquery @@ 'a fat cat sat on a mat and ate a fat rat'::tsvector;
?column?
----------
f
```



正如以上例子所建议的，一个tsquery并不只是一个未经处理的文本，顶多一个tsvector是这样。一个tsquery包含搜索术语，它们必须是已经正规化的词位，并且可以使用 AND、OR、NOT 以及 FOLLOWED BY 操作符结合多个术语（详见Section 8.11.2）。有几 个 函 数to_tsquery、plainto_tsquery以 及phraseto_tsquery可 用 于 将 用 户 书 写 的文本转换为正确的tsquery，它们会主要采用正则化出现在文本中的词的方法。相似地，to_tsvector被用来解析和正规化一个文档字符串。因此在实际上一个文本搜索匹配可能看起来更像： 

```sql
SELECT to_tsvector('fat cats ate fat rats') @@ to_tsquery('fat & rat');
?column?
----------
t
```

注意如果这个匹配被写成下面这样它将不会成功： 

```sql
SELECT 'fat cats ate fat rats'::tsvector @@ to_tsquery('fat & rat');
?column?
----------
f
```

因为这里不会发生词rats的正规化。一个tsvector的元素是词位，它被假定为已经正规化好，因此rats不匹配rat 

---

**我来理解一下**

- ::tsvector直接转换成文本向量，这个强制转换的东西假定已经正规化了，存的是词位。
- to_tsvector函数将文本正规化处理成词位。

---

@@操 作 符 也 支 持text输 出 ， 它 允 许 在 简 单 情 况 下 跳 过 从 文 本 字 符 串到tsvector或tsquery的显式转换。可用的变体是： 